import { CliRuntimeActivator } from '@kingjs/cli-runtime-activator'
import { CliRuntimeContainer } from '@kingjs/cli-runtime-container'
import { CliService } from '@kingjs/cli-service'
import { DirectedAcyclicGraph } from '@kingjs/directed-acyclic-graph'
import { CliRuntimeEventHub } from '@kingjs/cli-runtime-event-hub'
import { EventEmitter } from 'events'
import { 
  EXIT_SUCCESS, 
  EXIT_FAILURE, 
  EXIT_ERRORED,
  EXIT_SIGINT 
} from '@kingjs/cli-runtime-exit-code'

export class CliRuntimeState extends CliService { 
  static consumes = [ 'pulse', 'beforeAbort', 'beforeExit', 'error' ]
  static produces = [ 'is', 'update' ]
  static { this.initialize(import.meta) }

  #exitError
  #exitCode

  constructor(options) { 
    if (CliRuntimeState.initializing(new.target)) 
      return super()
    super(options)

    this.once('error', (exitCode, error) => {
      this.#exitCode = exitCode
      this.#exitError = error
      this.emit('is', 'failed', this.toString())
    })
    this.once('beforeAbort', () => this.emit('is', 'aborting'))
    this.once('beforeExit', (exitCode) => {
      this.#exitCode = exitCode
      this.emit('update', 'exiting', exitCode)
      this.emit('is',
        this.succeeded ? 'succeeded' :
        this.aborted ? 'aborted' :
        this.errored ? 'errored' :
        'failed', this.toString()
      )
    })

    this.on('pulse', (...record) => { this.emit('update', 'data', ...record) })
  }

  get exitError() { return this.#exitError }
  get exitErrorMessage() { return !this.exitError ? null :
    this.#exitError?.message ?? 'Unknown error' 
  }
  get exitCode() { return this.#exitCode }

  get running() { return this.exitCode === undefined }
  get succeeded() { return this.exitCode == EXIT_SUCCESS }
  get aborted() { return this.exitCode == EXIT_SIGINT }
  get failed() { return this.exitCode == EXIT_FAILURE }
  get errored() { 
    return process.exitCode == EXIT_ERRORED
      || process.exitCode == EXIT_ERRORED
      || process.exitCode == EXIT_ERRORED
  }

  toString() {
    if (this.succeeded) return 'Command succeeded'
    if (this.aborted) return `Command aborted`
    if (this.failed) return `Command failed`
    if (this.errored) return `Command exception: (${this.exitErrorMessage})`
    assert(this.running)
    return 'Running...'
  }
}

export class CliRuntime extends EventEmitter {
  #loader
  #path
  #class
  #info
  #parameters
  #eventHub
  #container

  constructor(loader, path, class$, info, parameters) {
    super()
    this.#loader = loader
    this.#path = path
    this.#class = class$
    this.#info = info
    this.#eventHub = new CliRuntimeEventHub(this, { 
      produces: [ 'error', 'beforeAbort', 'beforeExit' ],
      consumes: [ 'error' ]
    })
    this.#parameters = (parameters).sort((a, b) => a.position - b.position)
    this.#container = new CliRuntimeContainer(this.#eventHub)

    this.on('error', 
      (error) => console.error(error)
    )
  }

  get loader() { return this.#loader }
  get path() { return this.#path }
  get class() { return this.#class }
  get info() { return this.#info }
  *parameters() { yield* this.#parameters }

  #buildFrame(userArgs) {
    // Assume argv is an object generated by a cli framework like yargs;
    // Assume argv names match the style entered on the command line;
    // Assume argv properties are in kabab case and positional args are named.

    // Return an array of positional arguments with an additional last element
    // which is an object containing the option arguments with names converted
    // to camel case.
    const runtimeArgs = []

    const options = { }
    options._info = new CliRuntimeContext(this, options)
    
    // goto => stackframes (mixed => [...positional, {...options}])
    for (const parameter of this.#parameters) {
      const { name, kababName, isPositional } = parameter
      const userName = kababName ?? name
      if (isPositional) {
        runtimeArgs.push(userArgs[userName])
      } else if (Object.hasOwn(userArgs, userName)) {
        options[name] = userArgs[userName]
      }
    }
    runtimeArgs.push(options)

    return runtimeArgs
  }

  async #activate(userArgs) {
    // cli => javascript casing (kabab => camel)
    const runtimeArgs = this.#buildFrame(userArgs)
    const activator = new CliRuntimeActivator(this.class)
    return await activator.activate(...runtimeArgs)
  }

  async #dispose() {
    const services = new DirectedAcyclicGraph(this.#class, 
      function *services(class$) {
        for (const current of class$.hierarchy())
          for (const name of current.ownServiceNames())
            yield current.getOwnService(name)
      }
    )

    for (const class$ of services.transpose())
      await this.#container.dispose(class$)
  }

  activateService(service, options) {
    return this.#container.activate(service, options)
  }

  async execute(userArgs) {

    // trap unhandledRejection
    const onError = (error) => this.emit('error', error)
    process.on('unhandledRejection', onError)
    process.once('beforeExit', () => { 
      process.off('unhandledRejection', onError)
    })

    try
    {
      // unstructured => structured error handling
      const controller = new AbortController()

      let sigint = undefined
      const result = await Promise.race([ 
        // functional => object oriented execution
        this.#activate(userArgs).then(async instance => {
          try {
            this.#eventHub.register(instance)
            const result = await instance.execute(controller.signal)
            return result
          } catch (error) {
            if (error instanceof AbortError) return
            this.on('error', error)
          } finally {
            this.#eventHub.quiesce(instance)
          }
        }), 

        // signaling => event oriented abortion
        new Promise((resolve) => process.on('SIGINT', 
          sigint = async () => {
            this.emit('beforeAbort')
            controller.abort()
            resolve(EXIT_SIGINT)
          })
        )
      ]).finally(() => process.off('SIGINT', sigint))

      const exitCode = (result === undefined ? EXIT_SUCCESS
        : result === true ? EXIT_SUCCESS
        : result === false ? EXIT_FAILURE
        : typeof result == 'number' ? result
        : EXIT_FAILURE)

      this.emit('beforeExit', process.exitCode = exitCode)
      this.#dispose()
        
    } catch (error) {
      this.on('error', process.exitCode = EXIT_ERRORED, error)
    }
  }
}

export class CliRuntimeContext {
  #runtime
  #options

  constructor(runtime, options) {
    this.#runtime = runtime
    this.#options = options
  }

  get info() { return this.#runtime.info }
  get loader() { return this.#runtime.loader }

  getServices(class$) {
    const result = { }
    for (const name of class$.ownServiceNames()) {
      const service = class$.getOwnService(name)
      result[name] = this.#runtime.activateService(service, this.#options) 
    }
    return result
  }
}
